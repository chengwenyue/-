# 数据库事务



## 1. 事务隔离性出现的问题



1. 脏读：读到其他事务未提交的数据。
2. 不可重复读：在一个事务读到其他事务修改的数据，并且每次读取都是最新值，造成每次读取的值都不一样。
3. 幻读：根据条件查询出其他事务插入的数据。

> 幻读和不可重复读的区别为，幻读指的是读取到其他事务插入的数据，也就是每一次读取都比前一次读取的记录要多。不可重复读指的连续读取同一条记录，因为读取到其他事务修改的数据，所以每次读取到的值都不一样。简单理解就是幻读：读取到插入的值，不可重复读：读取到修改的值。
>
> 
> 问题严重性 ：脏读 > 不可重复读 > 幻读



## 2. 事务的隔离级别



1. read uncommited  读未提交 ： 可以读取到其他事务未提交到数据
2. read commited 读已提交 :  读取其他事务提交的数据
3. repeatable read 可重复读 ： 有事务在读取时，其他事务不能修改
4. serializable  可串行化 ： 串行化访问

> mysql默认的事务隔离级别为 repeatable read



## 3. 解决事务隔离性两种方案

1、读使用 MVCC + 写加锁方式

2、读写都使用加锁方式 

> 针对写写的冲突，Mysql使用的是加锁的方式解决。

MVCC的读取是快照读，读取是的历史的数据，不是数据库当前的数据。而有些时候业务需要每次都读取最新的数据，这时就不能使用快照读了，Mysql提供一种特殊的读取，加锁读取数据，也称锁定读，当前读等。

- 快照读：就是select
  - select * from table ….;
- 当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。
  - select * from table where ? lock in share mode; // 加读锁
  - select * from table where ? for update;// 加写锁
  - insert;
  - update ;
  - delete;

很明显，采用`MVCC`方式的话，`读-写`操作彼此并不冲突，性能更高，采用`加锁`方式的话，`读-写`操作彼此需要排队执行，影响性能。一般情况下我们当然愿意采用`MVCC`来解决`读-写`操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用`加锁`的方式执行，那也是没有办法的事。