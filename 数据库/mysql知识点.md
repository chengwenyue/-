## mysql知识点



### 1. mysql主从复制原理

![mysql主从](../images/mysql主从.jpg)

- MySQL master 将数据变更写入二进制日志( binary log, 其中记录叫做二进制日志事件binary log events，可以通过 show binlog events 进行查看)
- MySQL slave 将 master 的 binary log events 拷贝到它的中继日志(relay log)
- MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据



### 2. 唯一索引和普通索引的区别

问题前要:对于一个字段,它的更新操作很频繁,那么应该使用普通索引还是唯一索引?
结论：
如果业务能够保证唯一性应该尽量选择普通索引而不是唯一索引
从查询和更新两方面说明：
查询：

查询来说二者的区别是
普通索引查到符合条件的项后会继续查找下一项，如果下一项不符合再返回
唯一索引则是查到符合条件的项后就直接返回
其实这两种方式效率几乎没有差别，因为查找都是先读取数据项然后在内存中进行的所以多读取一次并不会带来很大的影响

更新：
对于更新操作二者还是有很大区别的，要理解他们之间的区别首先要理解change buffer
change buffer是用来记录更新操作的一种行为，在没有把数据项从硬盘读取到内存中时，进行更新操作会先将操作记录的change buffer中
在下一次进行select的时候在把数据项读取到内存中时，会对数据项执行change buffer中的命令，这个过程也成为merge
所以唯一索引的更新操作往往是这样，首先判断要插入的项在数据库中存不存在，这里就涉及到了一个读的问题，往往这个时候就会把数据从硬盘读取到内存中，如果这个时候还使用change buffer的意义并不大
因为change buffer存在的意义就是减少磁盘于内存的IO，现在数据项已经在内存中了，可以直接修改，所以唯一索引是不适用change buffer的
普通索引的更新操作
普通索引往往是将操作记录到change buffer中，在下一次读取的时候执行这些操作，可以显著减少磁盘与内存的IO操作，从而提高效率

选择：
如果是读取远大于更新和插入的表，唯一索引和普通索引都可以，但是如果业务需求相反，个人觉得应该使用普通索引，当然如果是那种更新完要求立即可见的需求，就是刚更新完就要再查询的，这种情况下反而不推荐普通索引，因为这样会频繁的产生merge操作，起不到change buffer的作用，反而需要额外空间来维护change buffer就有点得不偿失了



### 3. 索引的使用

索引能增加查询速度，但是也需要付出代价。空间上，每个索引对应一个B+树，需要占用存储空间，时间上，对表的增删改都需要消耗时间维护索引。



#### 1. 索引使用情况

```sql
CREATE TABLE person_info(
    id INT NOT NULL auto_increment,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
```

1. 全值匹配

> 索引的列和条件的列一致，而且都使用等值查询话，就是全值匹配。
>
> SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';

2. 匹配左边的列

> 搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行。

需要注意的是，左边的列必须全部出现，如果只出现一部分，也不能使用索引。

<span style="color:red">如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列</span>

3. 匹配列前缀

> 字符串索引在创建的时候会按照字符串前缀排序，所以如果模糊查询前缀字符串时，就能使用匹配列前缀
>
> SELECT * FROM person_info WHERE name LIKE 'As%';

利用Mysql的这种索引使用方式，可以将字符串逆序存储，然后在建索引就可以实现后缀匹配。例如

查询以com结尾的url，直接建索引查询`'%com'`是使用不了字符串的前缀匹配的，但是逆序存储后，在建索引，使用`'moc%'`匹配，可以满足前缀匹配，在业务上也满足后缀匹配。

```
+----------------+
| url            |
+----------------+
| www.baidu.com  |
| www.google.com |
| www.gov.cn     |
| ...            |
| www.wto.org    |
+----------------+
```
逆序存储后

```
+----------------+
| url            |
+----------------+
| moc.udiab.www  |
| moc.elgoog.www |
| nc.vog.www     |
| ...            |
| gro.otw.www    |
+----------------+
```

4. 精确匹配某一列并范围匹配另外一列

> 对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找
>
> SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday > '1980-01-01' AND birthday < '2000-12-31' AND phone_number > '15100000000';
>
> name是等值查询，birthday 就可以使用范围查询，但是phone_number 就不能使用索引了

#### 2. 索引排序



#### 3. 索引排序



#### 4. 二级索引 + 回表

由于索引的列不能完全覆盖查询的列，所以需要进行回表操作，但是回表操作是随机IO（主键Id不连续）如果回表的数据比较大，例如回表的数据占全表数据的90%，回表操作的耗时可能会比全表扫描（连续IO）耗时还长，虽然全表扫描的数据比回表少，但是考虑随机IO和连续IO的性能，这种情况是存在的，所以MySQL的查询优化器，就不会使用二级索引，而使用全表扫描。

所以使用二级索引要尽量命中的数据少，或者查询的列全部在二级索引中，这样就不用回表，Mysql称为这种查询列都在索引中的操作叫：索引覆盖。



### 4. Mysql索引优化，创建索引，使用索引，优化sql



