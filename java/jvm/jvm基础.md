# JVM基础

JVM由以下几部分组成

1. 类加载子系统
2. 运行时数据区
3. 执行引擎
4. 垃圾回收器

## 1. 类加载子系统

Jvm加载一个类的流程如下：

加载-> {验证 -> 准备 -> 解析}(链接) -> 初始化 -> 使用 -> 卸载

### 1.1 加载

JVM根据类的全限定名去加载类的二进制文件，加载工具为类加载器。

类加载器采用两种策略，1. 双亲委派，2. 全盘委托

类加载器可以分为两大类，1. JVM提供的 2. 用户自定义的。

详细可以参考如下文章 [tomcat类加载器](../tomcat/tomcat类加载器.md)

JVM何时会加载一个类？



### 1.2 验证

验证过程主要是jvm对字节码的校验。

1. 判断是否以魔数开头
2. 字节码的版本是否符合



## 2. 运行时数据

JVM 内存布局总体如下图：

![Java内存布局](https://p0.meituan.net/travelcube/132ba6ba720f2bfc6c69b1ce490f7c87693987.jpg)



运行时数据包括，程序计数器，VMStack（虚拟机栈），堆，运行时常量池，方法区，本地方法栈。

运行时常量池包含来着字节码文件的常量池，符号引用和字面量，方法区包含方法和字段的代码，类似操作系统的代码段（code segment ）,存放方法的代码指令文本。

类加载之后，常量池的内容会进入运行时常量池，这时候里面的数据也许还保持着符号引用。

常量池有运行时常量池和String常量池和class文件中的静态常量池。

​	运行时常量池是class中常量池的一种运行时的形式，包含符号引用和字面量，jdk1.8后在方法区分配。包含类元信息，方法段等，字节码常量池等，存放在元空间中。

​	String常量池是jvm存放字符串的一个缓存池，由StringTable实现，StringTable的key是引用，value是堆中真实的字符串地址。返回给Java层的实际上是句柄引用，指向StringTable的key。

JDK1.8 静态变量存放在 Class对象中，而Class对象存放在堆中，静态变量也都存放在堆中。可参考如下博客：

https://blog.csdn.net/x_iya/article/details/81260154#comments

https://www.iteye.com/blog/rednaxelafx-1847971



对象头计算

- 在32位系统中，存放 Class 的指针空间大小为 4 字节，MarkWord 为 4 字节，即对象头为 8 字节
- 在64 位系统中，存放 Class 指针的空间大小为 8 字节， MarkWord 为 8 字节，即对象头大小为 8 字节
- 64 位系统下，如果开启了指针压缩，存放 Class指针的空间大小为 4 字节，MarkWord 为 8 字节，即对象头为 12 字节
- 对于对象数据结构，参照上述三个规则，额外加上一个数组长度所含用的 4 个字节，就是最终对象头的大小
- 计算对象的大小时，**静态数据**是不会被考虑进去的